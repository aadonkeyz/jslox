{"version":3,"sources":["compiler/scanner/token.ts","compiler/semantic/ScopeAnalyst.ts","compiler/scanner/index.ts","compiler/parser/expression.ts","compiler/parser/statement.ts","compiler/parser/index.ts","compiler/util/produceError.ts","compiler/environment/index.ts","compiler/interpreter/LoxInstance.ts","compiler/interpreter/LoxClass.ts","compiler/interpreter/LoxReturn.ts","compiler/interpreter/LoxFunction.ts","compiler/interpreter/index.ts","compiler/index.ts","page/Playground/index.tsx","App.tsx","index.tsx"],"names":["TokenType","FunctionType","ClassType","KEYWORDS_MAP","AND","CLASS","ELSE","FALSE","FUN","FOR","IF","NIL","OR","PRINT","RETURN","SUPER","THIS","TRUE","VAR","WHILE","Token","props","type","lexeme","line","column","literal","this","Scanner","source","tokens","start","current","errors","isAtEnd","scanToken","push","EOF","calculateColumn","length","code","advance","addToken","LEFT_PARENTHESE","RIGHT_PARENTHESE","LEFT_BRACE","RIGHT_BRACE","COMMA","DOT","MINUS","PLUS","SEMICOLON","STAR","match","BANG_EQUAL","BANG","EQUAL_EQUAL","EQUAL","LESS_EQUAL","LESS","GREATER_EQUAL","GREATER","peek","SLASH","handleString","isDigit","handleDigit","isAlpha","handleAlpha","message","expected","test","value","slice","STRING","peekNext","Number","NUMBER","IDENTIFIER","targetIndex","lastIndexOf","BaseExpression","visitor","BinaryExpression","left","operator","right","visitBinaryExpression","LogicalExpression","visitLogicalExpression","GroupingExpression","expression","visitGroupingExpression","LiteralExpression","visitLiteralExpression","UnaryExpression","visitUnaryExpression","VariableExpression","name","visitVariableExpression","AssignmentExpression","visitAssignmentExpression","CallExpression","callee","args","endParenthese","visitCallExpression","GetExpression","object","visitGetExpression","SetExpression","visitSetExpression","ThisExpression","keyword","visitThisExpression","SuperExpression","method","visitSuperExpression","BaseStatement","ExpressionStatement","visitExpressionStatement","IfStatement","condition","thenBranch","elseBranch","visitIfStatement","PrintStatement","visitPrintStatement","WhileStatement","body","visitWhileStatement","ForStatement","initializer","updator","visitForStatement","VarStatement","visitVarStatement","BlockStatement","statements","visitBlockStatement","FunctionStatement","params","visitFunctionStatement","ReturnStatement","visitReturnStatement","ClassStatement","superclass","methods","visitClassStatement","Parser","statement","declaration","funDecl","classDecl","varDecl","error","synchronize","kind","consume","check","Statement","block","Expression","previous","ifStmt","printStmt","returnStmt","whileStmt","forStmt","exprStmt","undefined","Error","assignment","logicOr","equals","logicAnd","equality","comparison","term","factor","unary","call","primary","previousType","finishCall","tokenTypes","i","tokenType","ScopeAnalyst","scopes","scopeRecord","functionType","classType","Map","NONE","evaluateList","list","evaluateItem","node","accept","previousFunctionType","forEach","item","declare","define","pop","set","evaluateFunction","FUNCTION","INITIALIZER","previousClassType","super","SUBCLASS","METHOD","calculate","produceError","Environment","enclosing","values","get","distance","environment","assign","LoxInstance","belongClass","fields","findMethod","bind","LoxClass","init","arity","interpreter","instance","LoxReturn","LoxFunction","closure","isInitializer","returnVal","Interpreter","global","execute","loxFunction","evaluate","reduce","pre","cur","loxClass","val","console","log","newEnvironment","numberBinaryCalculate","token","has","getEnvironmentByDistance","map","obj","Compiler","scanner","parser","scopeAnalyst","scan","parse","analysis","interpret","PROBLEMS","CONSOLE","TAB_CONFIGS","key","label","Playground","show","useState","activeKey","setActiveKey","setErrors","output","setOutput","compilerRef","useRef","handleCodeChange","useCallback","debounce","compiler","window","zzz","newErrors","concat","useEffect","originalLog","data","Object","JSON","stringify","err","prototype","toString","apply","className","style","display","height","defaultLanguage","onChange","tabBarExtraContent","danger","icon","CloseCircleOutlined","marginRight","onClick","transform","background","CaretRightOutlined","disabled","run","Content","header","footer","bordered","dataSource","renderItem","Item","tabName","TabPane","tab","PLAYGROUND","GRAMMER","App","active","setActive","mode","theme","selectedKeys","flex","border","title","src","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b15dc35c.chunk.js","sourcesContent":["export enum TokenType {\n  // Keywords.\n  AND = 'and',\n  CLASS = 'class',\n  ELSE = 'else',\n  FALSE = 'false',\n  FUN = 'fun',\n  FOR = 'for',\n  IF = 'if',\n  NIL = 'nil',\n  OR = 'or',\n  PRINT = 'print',\n  RETURN = 'return',\n  SUPER = 'super',\n  THIS = 'this',\n  TRUE = 'true',\n  VAR = 'var',\n  WHILE = 'while',\n\n  // Single-character tokens.\n  LEFT_PARENTHESE = '(',\n  RIGHT_PARENTHESE = ')',\n  LEFT_BRACE = '{',\n  RIGHT_BRACE = '}',\n  COMMA = ',',\n  DOT = '.',\n  MINUS = '-',\n  PLUS = '+',\n  SEMICOLON = ';',\n  SLASH = '/',\n  STAR = '*',\n\n  // One or two character tokens.\n  BANG = '!',\n  BANG_EQUAL = '!=',\n  EQUAL = '=',\n  EQUAL_EQUAL = '==',\n  GREATER = '>',\n  GREATER_EQUAL = '>=',\n  LESS = '<',\n  LESS_EQUAL = '<=',\n\n  // Literals.\n  IDENTIFIER = 'identifier',\n  STRING = 'string',\n  NUMBER = 'number',\n\n  EOF = 'eof',\n}\n\nexport const KEYWORDS_MAP = {\n  [TokenType.AND]: TokenType.AND,\n  [TokenType.CLASS]: TokenType.CLASS,\n  [TokenType.ELSE]: TokenType.ELSE,\n  [TokenType.FALSE]: TokenType.FALSE,\n  [TokenType.FUN]: TokenType.FUN,\n  [TokenType.FOR]: TokenType.FOR,\n  [TokenType.IF]: TokenType.IF,\n  [TokenType.NIL]: TokenType.NIL,\n  [TokenType.OR]: TokenType.OR,\n  [TokenType.PRINT]: TokenType.PRINT,\n  [TokenType.RETURN]: TokenType.RETURN,\n  [TokenType.SUPER]: TokenType.SUPER,\n  [TokenType.THIS]: TokenType.THIS,\n  [TokenType.TRUE]: TokenType.TRUE,\n  [TokenType.VAR]: TokenType.VAR,\n  [TokenType.WHILE]: TokenType.WHILE,\n};\n\nexport type LiteralValue = number | string | boolean | null;\nclass Token {\n  type: TokenType;\n  lexeme: string;\n  line: number;\n  column: number;\n  literal?: LiteralValue;\n\n  constructor(props: {\n    type: TokenType;\n    lexeme: string;\n    line: number;\n    column: number;\n    literal?: LiteralValue;\n  }) {\n    this.type = props.type;\n    this.lexeme = props.lexeme;\n    this.line = props.line;\n    this.column = props.column;\n    this.literal = props.literal;\n  }\n}\n\nexport default Token;\n","import { Expression, Statement } from '../parser';\nimport { Token } from '../scanner';\n\nenum FunctionType {\n  NONE,\n  FUNCTION,\n  METHOD,\n  INITIALIZER,\n}\n\nenum ClassType {\n  NONE,\n  CLASS,\n  SUBCLASS,\n}\n\nclass ScopeAnalyst {\n  statements: Statement.BaseStatement[];\n  scopes: Record<string, boolean>[];\n  scopeRecord: Map<Expression.BaseExpression, number>;\n  functionType: FunctionType;\n  classType: ClassType;\n  errors: { line: number; column: number; message: string }[];\n\n  constructor(statements: Statement.BaseStatement[]) {\n    this.statements = statements;\n    this.scopes = [];\n    this.scopeRecord = new Map();\n    this.functionType = FunctionType.NONE;\n    this.classType = ClassType.NONE;\n    this.errors = [];\n  }\n\n  analysis(): void {\n    this.evaluateList(this.statements);\n  }\n\n  evaluateList(\n    list: Statement.BaseStatement[] | Expression.BaseExpression[],\n  ): void {\n    for (let i = 0; i < list.length; i++) {\n      this.evaluateItem(list[i]);\n    }\n  }\n\n  evaluateItem(\n    node: Statement.BaseStatement | Expression.BaseExpression,\n  ): void {\n    node.accept(this);\n  }\n\n  evaluateFunction(\n    node: Statement.FunctionStatement,\n    type: FunctionType,\n  ): void {\n    const previousFunctionType = this.functionType;\n    this.functionType = type;\n\n    this.scopes.push({});\n\n    node.params.forEach((item) => {\n      this.declare(item);\n      this.define(item);\n    });\n    this.evaluateList(node.body.statements);\n\n    this.scopes.pop();\n    this.functionType = previousFunctionType;\n  }\n\n  declare(name: Token): void {\n    if (this.scopes.length !== 0) {\n      this.scopes[this.scopes.length - 1][name.lexeme] = false;\n    }\n  }\n\n  define(name: Token): void {\n    if (this.scopes.length !== 0) {\n      this.scopes[this.scopes.length - 1][name.lexeme] = true;\n    }\n  }\n\n  calculate(\n    node: Statement.BaseStatement | Expression.BaseExpression,\n    name: Token,\n  ): void {\n    for (let i = this.scopes.length - 1; i >= 0; i--) {\n      if (name.lexeme in this.scopes[i]) {\n        this.scopeRecord.set(node, this.scopes.length - 1 - i);\n        return;\n      }\n    }\n  }\n\n  visitExpressionStatement(node: Statement.ExpressionStatement): void {\n    this.evaluateItem(node.expression);\n  }\n\n  visitIfStatement(node: Statement.IfStatement): void {\n    this.evaluateItem(node.condition);\n    this.evaluateItem(node.thenBranch);\n    node.elseBranch && this.evaluateItem(node.elseBranch);\n  }\n\n  visitPrintStatement(node: Statement.PrintStatement): void {\n    this.evaluateItem(node.expression);\n  }\n\n  visitWhileStatement(node: Statement.WhileStatement): void {\n    this.evaluateItem(node.condition);\n    this.evaluateItem(node.body);\n  }\n\n  visitForStatement(node: Statement.ForStatement): void {\n    this.scopes.push({});\n    node.initializer && this.evaluateItem(node.initializer);\n    node.condition && this.evaluateItem(node.condition);\n    node.updator && this.evaluateItem(node.updator);\n    this.evaluateItem(node.body);\n    this.scopes.pop();\n  }\n\n  visitVarStatement(node: Statement.VarStatement): void {\n    this.declare(node.name);\n    node.initializer && this.evaluateItem(node.initializer);\n    this.define(node.name);\n  }\n\n  visitBlockStatement(node: Statement.BlockStatement): void {\n    this.scopes.push({});\n    this.evaluateList(node.statements);\n    this.scopes.pop();\n  }\n\n  visitFunctionStatement(node: Statement.FunctionStatement): void {\n    this.declare(node.name);\n    this.define(node.name);\n\n    this.evaluateFunction(node, FunctionType.FUNCTION);\n  }\n\n  visitReturnStatement(node: Statement.ReturnStatement): void {\n    if (this.functionType === FunctionType.NONE) {\n      this.errors.push({\n        line: node.keyword.line,\n        column: node.keyword.column,\n        message: \"Can't return from top-level code\",\n      });\n    }\n\n    if (\n      !(\n        node.value instanceof Expression.LiteralExpression &&\n        node.value.value === null\n      )\n    ) {\n      if (this.functionType === FunctionType.INITIALIZER) {\n        this.errors.push({\n          line: node.keyword.line,\n          column: node.keyword.column,\n          message: \"Can't use return a value from an initializer\",\n        });\n      }\n\n      this.evaluateItem(node.value);\n    }\n  }\n\n  visitClassStatement(node: Statement.ClassStatement): void {\n    const previousClassType = this.classType;\n    this.classType = ClassType.CLASS;\n\n    this.declare(node.name);\n\n    if (node.superclass) {\n      if (node.name.lexeme === node.superclass.name.lexeme) {\n        this.errors.push({\n          line: node.name.line,\n          column: node.name.column,\n          message: `A class can't inherit from itself(\"${node.name.lexeme}\")`,\n        });\n      }\n\n      this.evaluateItem(node.superclass);\n\n      this.scopes.push({ super: true });\n\n      this.classType = ClassType.SUBCLASS;\n    }\n\n    this.scopes.push({ this: true });\n\n    node.methods.forEach((item) => {\n      this.evaluateFunction(\n        item,\n        item.name.lexeme === 'init'\n          ? FunctionType.INITIALIZER\n          : FunctionType.METHOD,\n      );\n    });\n\n    this.scopes.pop();\n\n    if (node.superclass) {\n      this.scopes.pop();\n    }\n\n    this.define(node.name);\n\n    this.classType = previousClassType;\n  }\n\n  visitBinaryExpression(node: Expression.BinaryExpression): void {\n    this.evaluateItem(node.left);\n    this.evaluateItem(node.right);\n  }\n\n  visitLogicalExpression(node: Expression.LogicalExpression): void {\n    this.evaluateItem(node.left);\n    this.evaluateItem(node.right);\n  }\n\n  visitGroupingExpression(node: Expression.GroupingExpression): void {\n    this.evaluateItem(node.expression);\n  }\n\n  visitLiteralExpression(node: Expression.LiteralExpression): void {}\n\n  visitUnaryExpression(node: Expression.UnaryExpression): void {\n    this.evaluateItem(node.expression);\n  }\n\n  visitVariableExpression(node: Expression.VariableExpression): void {\n    if (\n      this.scopes.length !== 0 &&\n      this.scopes[this.scopes.length - 1][node.name.lexeme] === false\n    ) {\n      this.errors.push({\n        line: node.name.line,\n        column: node.name.column,\n        message: `Can't read local variable in its own initializer(\"${node.name.lexeme}\")`,\n      });\n    }\n\n    this.calculate(node, node.name);\n  }\n\n  visitAssignmentExpression(node: Expression.AssignmentExpression): void {\n    this.evaluateItem(node.value);\n    this.calculate(node, node.name);\n  }\n\n  visitCallExpression(node: Expression.CallExpression): void {\n    this.evaluateItem(node.callee);\n    this.evaluateList(node.args);\n  }\n\n  visitGetExpression(node: Expression.GetExpression): void {\n    this.evaluateItem(node.object);\n  }\n\n  visitSetExpression(node: Expression.SetExpression): void {\n    this.evaluateItem(node.value);\n    this.evaluateItem(node.object);\n  }\n\n  visitThisExpression(node: Expression.ThisExpression): void {\n    if (this.classType === ClassType.NONE) {\n      this.errors.push({\n        line: node.keyword.line,\n        column: node.keyword.column,\n        message: 'Can\\'t use \"this\" outside of a class',\n      });\n    }\n    this.calculate(node, node.keyword);\n  }\n\n  visitSuperExpression(node: Expression.SuperExpression): void {\n    if (this.classType === ClassType.NONE) {\n      this.errors.push({\n        line: node.keyword.line,\n        column: node.keyword.column,\n        message: 'Can\\'t use \"super\" outside of a class',\n      });\n    } else if (this.classType === ClassType.CLASS) {\n      this.errors.push({\n        line: node.keyword.line,\n        column: node.keyword.column,\n        message: 'Can\\'t use \"super\" in a class with no superclass',\n      });\n    }\n\n    this.calculate(node, node.keyword);\n  }\n}\n\nexport default ScopeAnalyst;\n","import Token, { KEYWORDS_MAP, TokenType, LiteralValue } from './token';\n\nclass Scanner {\n  source: string;\n  tokens: Token[];\n  start: number;\n  current: number;\n  line: number;\n  errors: {\n    line: number;\n    column: number;\n    message: string;\n  }[];\n\n  constructor(source: string) {\n    this.source = source;\n    this.tokens = [];\n    this.start = 0;\n    this.current = 0;\n    this.line = 1;\n    this.errors = [];\n  }\n\n  scan(): void {\n    while (!this.isAtEnd()) {\n      this.start = this.current;\n      this.scanToken();\n    }\n\n    this.tokens.push(\n      new Token({\n        type: TokenType.EOF,\n        lexeme: '',\n        line: this.line,\n        column: this.calculateColumn(this.source.length - 1),\n      }),\n    );\n  }\n\n  scanToken(): void {\n    const code = this.advance();\n\n    switch (code) {\n      case '(':\n        this.addToken(TokenType.LEFT_PARENTHESE);\n        break;\n      case ')':\n        this.addToken(TokenType.RIGHT_PARENTHESE);\n        break;\n      case '{':\n        this.addToken(TokenType.LEFT_BRACE);\n        break;\n      case '}':\n        this.addToken(TokenType.RIGHT_BRACE);\n        break;\n      case ',':\n        this.addToken(TokenType.COMMA);\n        break;\n      case '.':\n        this.addToken(TokenType.DOT);\n        break;\n      case '-':\n        this.addToken(TokenType.MINUS);\n        break;\n      case '+':\n        this.addToken(TokenType.PLUS);\n        break;\n      case ';':\n        this.addToken(TokenType.SEMICOLON);\n        break;\n      case '*':\n        this.addToken(TokenType.STAR);\n        break;\n      case '!':\n        this.addToken(this.match('=') ? TokenType.BANG_EQUAL : TokenType.BANG);\n        break;\n      case '=':\n        this.addToken(\n          this.match('=') ? TokenType.EQUAL_EQUAL : TokenType.EQUAL,\n        );\n        break;\n      case '<':\n        this.addToken(this.match('=') ? TokenType.LESS_EQUAL : TokenType.LESS);\n        break;\n      case '>':\n        this.addToken(\n          this.match('=') ? TokenType.GREATER_EQUAL : TokenType.GREATER,\n        );\n        break;\n      case '/':\n        if (this.match('/')) {\n          while (this.peek() !== '\\n' && !this.isAtEnd()) {\n            this.advance();\n          }\n        } else {\n          this.addToken(TokenType.SLASH);\n        }\n        break;\n      case ' ':\n      case '\\r':\n      case '\\t':\n        break;\n      case '\\n':\n        this.line++;\n        break;\n      case '\"':\n      case \"'\":\n        this.handleString(code);\n        break;\n      default:\n        if (this.isDigit(code)) {\n          this.handleDigit();\n        } else if (this.isAlpha(code)) {\n          this.handleAlpha();\n        } else {\n          this.errors.push({\n            line: this.line,\n            column: this.calculateColumn(this.current - 1),\n            message: 'Unexpected character',\n          });\n        }\n        break;\n    }\n  }\n\n  isAtEnd(): boolean {\n    return this.current >= this.source.length;\n  }\n\n  advance(): string {\n    return this.source[this.current++] || '';\n  }\n\n  peek(): string {\n    return this.source[this.current] || '';\n  }\n\n  peekNext(): string {\n    return this.source[this.current + 1] || '';\n  }\n\n  match(expected: string): boolean {\n    if (this.isAtEnd()) {\n      return false;\n    }\n\n    if (this.source[this.current] !== expected) {\n      return false;\n    }\n\n    this.current++;\n    return true;\n  }\n\n  isDigit(code: string): boolean {\n    return /^[0-9]$/.test(code);\n  }\n\n  isAlpha(code: string): boolean {\n    return /^[_a-zA-Z]$/.test(code);\n  }\n\n  handleString(code: '\"' | \"'\"): void {\n    while (this.peek() !== code && !this.isAtEnd()) {\n      if (this.peek() === '\\n') {\n        this.line++;\n      }\n      this.advance();\n    }\n\n    if (this.isAtEnd()) {\n      this.errors.push({\n        line: this.line,\n        column: this.calculateColumn(this.current - 1),\n        message: 'Unterminated string',\n      });\n      return;\n    }\n\n    this.advance();\n\n    const value = this.source.slice(this.start + 1, this.current - 1);\n    this.addToken(TokenType.STRING, value);\n  }\n\n  handleDigit(): void {\n    while (this.isDigit(this.peek())) {\n      this.advance();\n    }\n\n    if (this.peek() === '.' && this.isDigit(this.peekNext())) {\n      this.advance();\n\n      while (this.isDigit(this.peek())) {\n        this.advance();\n      }\n    }\n\n    const value = Number(this.source.slice(this.start, this.current));\n    this.addToken(TokenType.NUMBER, value);\n  }\n\n  handleAlpha(): void {\n    while (this.isAlpha(this.peek()) || this.isDigit(this.peek())) {\n      this.advance();\n    }\n\n    const lexeme = this.source.slice(this.start, this.current);\n    const type =\n      lexeme in KEYWORDS_MAP\n        ? KEYWORDS_MAP[lexeme as keyof typeof KEYWORDS_MAP]\n        : TokenType.IDENTIFIER;\n\n    this.addToken(type);\n  }\n\n  addToken(type: TokenType, literal?: string | number): void {\n    const lexeme = this.source.slice(this.start, this.current);\n    this.tokens.push(\n      new Token({\n        type,\n        lexeme,\n        line: this.line,\n        column: this.calculateColumn(this.start),\n        literal,\n      }),\n    );\n  }\n\n  calculateColumn(targetIndex: number): number {\n    return targetIndex - this.source.slice(0, targetIndex).lastIndexOf('\\n');\n  }\n}\n\nexport { Scanner as default, Token, TokenType };\nexport type { LiteralValue };\n","import { Token, LiteralValue } from '../scanner';\nimport Interpreter from '../interpreter';\nimport { ScopeAnalyst } from '../semantic';\n\ntype Visitor = Interpreter | ScopeAnalyst;\n\nclass BaseExpression {\n  accept(visitor: Visitor): any {}\n}\n\nclass BinaryExpression extends BaseExpression {\n  left: BaseExpression;\n  operator: Token;\n  right: BaseExpression;\n\n  constructor(left: BaseExpression, operator: Token, right: BaseExpression) {\n    super();\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n\n  accept(visitor: Visitor) {\n    return visitor.visitBinaryExpression(this);\n  }\n}\n\nclass LogicalExpression extends BaseExpression {\n  left: BaseExpression;\n  operator: Token;\n  right: BaseExpression;\n\n  constructor(left: BaseExpression, operator: Token, right: BaseExpression) {\n    super();\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n\n  accept(visitor: Visitor) {\n    return visitor.visitLogicalExpression(this);\n  }\n}\n\nclass GroupingExpression extends BaseExpression {\n  expression: BaseExpression;\n\n  constructor(BaseExpression: BaseExpression) {\n    super();\n    this.expression = BaseExpression;\n  }\n\n  accept(visitor: Visitor) {\n    return visitor.visitGroupingExpression(this);\n  }\n}\n\nclass LiteralExpression extends BaseExpression {\n  value: LiteralValue;\n\n  constructor(value: LiteralValue) {\n    super();\n    this.value = value;\n  }\n\n  accept(visitor: Visitor) {\n    return visitor.visitLiteralExpression(this);\n  }\n}\n\nclass UnaryExpression extends BaseExpression {\n  operator: Token;\n  expression: BaseExpression;\n\n  constructor(operator: Token, expression: BaseExpression) {\n    super();\n    this.operator = operator;\n    this.expression = expression;\n  }\n\n  accept(visitor: Visitor) {\n    return visitor.visitUnaryExpression(this);\n  }\n}\n\nclass VariableExpression extends BaseExpression {\n  name: Token;\n\n  constructor(name: Token) {\n    super();\n    this.name = name;\n  }\n\n  accept(visitor: Visitor) {\n    return visitor.visitVariableExpression(this);\n  }\n}\n\nclass AssignmentExpression extends BaseExpression {\n  name: Token;\n  value: BaseExpression;\n\n  constructor(name: Token, value: BaseExpression) {\n    super();\n    this.name = name;\n    this.value = value;\n  }\n\n  accept(visitor: Visitor) {\n    return visitor.visitAssignmentExpression(this);\n  }\n}\n\nclass CallExpression extends BaseExpression {\n  callee: BaseExpression;\n  args: BaseExpression[];\n  endParenthese: Token;\n\n  constructor(\n    callee: BaseExpression,\n    args: BaseExpression[],\n    endParenthese: Token,\n  ) {\n    super();\n    this.callee = callee;\n    this.args = args;\n    this.endParenthese = endParenthese;\n  }\n\n  accept(visitor: Visitor) {\n    return visitor.visitCallExpression(this);\n  }\n}\n\nclass GetExpression extends BaseExpression {\n  object: BaseExpression;\n  name: Token;\n\n  constructor(object: BaseExpression, name: Token) {\n    super();\n    this.object = object;\n    this.name = name;\n  }\n\n  accept(visitor: Visitor) {\n    return visitor.visitGetExpression(this);\n  }\n}\n\nclass SetExpression extends BaseExpression {\n  object: BaseExpression;\n  name: Token;\n  value: BaseExpression;\n\n  constructor(object: BaseExpression, name: Token, value: BaseExpression) {\n    super();\n    this.object = object;\n    this.name = name;\n    this.value = value;\n  }\n\n  accept(visitor: Visitor) {\n    return visitor.visitSetExpression(this);\n  }\n}\n\nclass ThisExpression extends BaseExpression {\n  keyword: Token;\n\n  constructor(keyword: Token) {\n    super();\n    this.keyword = keyword;\n  }\n\n  accept(visitor: Visitor) {\n    return visitor.visitThisExpression(this);\n  }\n}\n\nclass SuperExpression extends BaseExpression {\n  keyword: Token;\n  method: Token;\n\n  constructor(keyword: Token, method: Token) {\n    super();\n    this.keyword = keyword;\n    this.method = method;\n  }\n\n  accept(visitor: Visitor) {\n    return visitor.visitSuperExpression(this);\n  }\n}\n\nexport {\n  BaseExpression,\n  BinaryExpression,\n  LogicalExpression,\n  GroupingExpression,\n  LiteralExpression,\n  UnaryExpression,\n  VariableExpression,\n  AssignmentExpression,\n  CallExpression,\n  GetExpression,\n  SetExpression,\n  ThisExpression,\n  SuperExpression,\n};\n","import Interpreter from '../interpreter';\nimport { ScopeAnalyst } from '../semantic';\nimport { Token } from '../scanner';\nimport { Expression } from '.';\n\ntype Visitor = Interpreter | ScopeAnalyst;\n\nclass BaseStatement {\n  accept(visitor: Visitor) {}\n}\n\nclass ExpressionStatement extends BaseStatement {\n  expression: Expression.BaseExpression;\n\n  constructor(expression: Expression.BaseExpression) {\n    super();\n    this.expression = expression;\n  }\n\n  accept(visitor: Visitor) {\n    visitor.visitExpressionStatement(this);\n  }\n}\n\nclass IfStatement extends BaseStatement {\n  condition: Expression.BaseExpression;\n  thenBranch: BaseStatement;\n  elseBranch?: BaseStatement;\n\n  constructor(\n    condition: Expression.BaseExpression,\n    thenBranch: BaseStatement,\n    elseBranch?: BaseStatement,\n  ) {\n    super();\n    this.condition = condition;\n    this.thenBranch = thenBranch;\n    this.elseBranch = elseBranch;\n  }\n\n  accept(visitor: Visitor) {\n    visitor.visitIfStatement(this);\n  }\n}\n\nclass PrintStatement extends BaseStatement {\n  expression: Expression.BaseExpression;\n\n  constructor(expression: Expression.BaseExpression) {\n    super();\n    this.expression = expression;\n  }\n\n  accept(visitor: Visitor) {\n    visitor.visitPrintStatement(this);\n  }\n}\n\nclass WhileStatement extends BaseStatement {\n  condition: Expression.BaseExpression;\n  body: BaseStatement;\n\n  constructor(condition: Expression.BaseExpression, body: BaseStatement) {\n    super();\n    this.condition = condition;\n    this.body = body;\n  }\n\n  accept(visitor: Visitor) {\n    visitor.visitWhileStatement(this);\n  }\n}\n\nclass ForStatement extends BaseStatement {\n  initializer?: BaseStatement;\n  condition?: Expression.BaseExpression;\n  updator?: Expression.BaseExpression;\n  body: BaseStatement;\n\n  constructor(props: {\n    initializer?: BaseStatement;\n    condition?: Expression.BaseExpression;\n    updator?: Expression.BaseExpression;\n    body: BaseStatement;\n  }) {\n    super();\n    this.initializer = props.initializer;\n    this.condition = props.condition;\n    this.updator = props.updator;\n    this.body = props.body;\n  }\n\n  accept(visitor: Visitor) {\n    visitor.visitForStatement(this);\n  }\n}\n\nclass VarStatement extends BaseStatement {\n  name: Token;\n  initializer?: Expression.BaseExpression;\n\n  constructor(name: Token, initializer?: Expression.BaseExpression) {\n    super();\n    this.name = name;\n    this.initializer = initializer;\n  }\n\n  accept(visitor: Visitor) {\n    visitor.visitVarStatement(this);\n  }\n}\n\nclass BlockStatement extends BaseStatement {\n  statements: BaseStatement[];\n\n  constructor(statements: BaseStatement[]) {\n    super();\n    this.statements = statements;\n  }\n\n  accept(visitor: Visitor) {\n    visitor.visitBlockStatement(this);\n  }\n}\n\nclass FunctionStatement extends BaseStatement {\n  name: Token;\n  params: Token[];\n  body: BlockStatement;\n\n  constructor(name: Token, params: Token[], body: BlockStatement) {\n    super();\n    this.name = name;\n    this.params = params;\n    this.body = body;\n  }\n\n  accept(visitor: Visitor) {\n    visitor.visitFunctionStatement(this);\n  }\n}\n\nclass ReturnStatement extends BaseStatement {\n  keyword: Token;\n  value: Expression.BaseExpression;\n\n  constructor(keyword: Token, value: Expression.BaseExpression) {\n    super();\n    this.keyword = keyword;\n    this.value = value;\n  }\n\n  accept(visitor: Visitor) {\n    visitor.visitReturnStatement(this);\n  }\n}\n\nclass ClassStatement extends BaseStatement {\n  name: Token;\n  superclass: Expression.VariableExpression | null;\n  methods: FunctionStatement[];\n\n  constructor(\n    name: Token,\n    superclass: Expression.VariableExpression | null,\n    methods: FunctionStatement[],\n  ) {\n    super();\n    this.name = name;\n    this.superclass = superclass;\n    this.methods = methods;\n  }\n\n  accept(visitor: Visitor) {\n    visitor.visitClassStatement(this);\n  }\n}\n\nexport {\n  BaseStatement,\n  ExpressionStatement,\n  IfStatement,\n  PrintStatement,\n  WhileStatement,\n  ForStatement,\n  VarStatement,\n  BlockStatement,\n  FunctionStatement,\n  ReturnStatement,\n  ClassStatement,\n};\n","import { Token, TokenType, LiteralValue } from '../scanner';\nimport * as Expression from './expression';\nimport * as Statement from './statement';\n\n/**\n * program         declaration* EOF\n * declaration     classDecl | funDecl | varDecl | statement\n * classDecl       \"class\" IDENTIFIER ( \"<\" IDENTIFIER )? \"{\" function* \"}\"\n * funDecl         \"fun\" function\n * function        IDENTIFIER \"(\" parameters? \")\" block\n * parameters      IDENTIFIER ( \",\" IDENTIFIER )*\n * varDecl         \"var\" IDENTIFIER ( \"=\" expression )? \";\"\n * statement       exprStmt | forStmt | ifStmt | printStmt | returnStmt | whileStmt | block\n * exprStmt        expression \";\"\n * ifStmt          \"if\" \"(\" expression \")\" statement ( \"else\" statement )?\n * forStmt         \"for\" \"(\" ( varDecl | exprStmt | \";\" ) expression? \";\" expression? \")\" statement\n * printStmt       \"print\" expression \";\"\n * returnStmt      \"return\" expression? \";\"\n * whileStmt       \"while\" \"(\" expression \")\" statement\n * block           \"{\" declaration* \"}\" ;\n *\n *\n *\n * expression      assignment\n * assignment      ( call \".\" )? IDENTIFIER \"=\" assignment | logicOr\n * logicOr         logicAnd (\"or\" logicAnd)*\n * logicAnd        equality (\"and\" equality)*\n * equality        comparison ( ( \"!=\" | \"==\" ) comparison )*\n * comparison      term ( ( \">\" | \">=\" | \"<\" | \"<=\" ) term )*\n * term            factor ( ( \"-\" | \"+\" ) factor )*\n * factor          unary ( ( \"/\" | \"*\" ) unary )*\n * unary           ( \"!\" | \"-\" ) unary | call\n * call            primary ( \"(\" arguments? \")\" | \".\" IDENTIFIER )*\n * arguments       expression ( \",\" expression )*\n * primary         NUMBER | STRING | \"true\" | \"false\" | \"nil\" | \"this\" | IDENTIFIER | \"(\" expression \")\" | \"super\" \".\" IDENTIFIER\n */\n\nclass Parser {\n  tokens: Token[];\n  current: number;\n  statements: Statement.BaseStatement[];\n  errors: { line: number; column: number; message: string }[];\n\n  constructor(tokens: Token[]) {\n    this.tokens = tokens;\n    this.current = 0;\n    this.statements = [];\n    this.errors = [];\n  }\n\n  parse() {\n    while (!this.isAtEnd()) {\n      const statement = this.declaration();\n      if (statement) {\n        this.statements.push(statement);\n      }\n    }\n  }\n\n  declaration(): Statement.BaseStatement | undefined {\n    try {\n      if (this.match([TokenType.FUN])) {\n        return this.funDecl('function');\n      }\n\n      if (this.match([TokenType.CLASS])) {\n        return this.classDecl();\n      }\n\n      if (this.match([TokenType.VAR])) {\n        return this.varDecl();\n      }\n\n      return this.statement();\n    } catch (error) {\n      this.synchronize();\n    }\n  }\n\n  funDecl(kind: 'function' | 'method'): Statement.FunctionStatement {\n    const name = this.consume(TokenType.IDENTIFIER, `Expect ${kind} name`);\n    this.consume(TokenType.LEFT_PARENTHESE, `Expect \"(\" after ${kind} name`);\n\n    const params: Token[] = [];\n    if (!this.check(TokenType.RIGHT_PARENTHESE)) {\n      do {\n        params.push(\n          this.consume(TokenType.IDENTIFIER, 'Expect parameter name'),\n        );\n      } while (this.match([TokenType.COMMA]));\n    }\n    this.consume(TokenType.RIGHT_PARENTHESE, 'Expect \")\" after parameters');\n\n    this.consume(TokenType.LEFT_BRACE, `Expect \"{\" before ${kind} body`);\n    const body = new Statement.BlockStatement(this.block());\n\n    return new Statement.FunctionStatement(name, params, body);\n  }\n\n  classDecl(): Statement.ClassStatement {\n    const name = this.consume(TokenType.IDENTIFIER, `Expect class name`);\n\n    let superclass = null;\n    if (this.match([TokenType.LESS])) {\n      this.consume(TokenType.IDENTIFIER, 'Expect superclass name');\n      superclass = new Expression.VariableExpression(this.previous());\n    }\n\n    this.consume(TokenType.LEFT_BRACE, 'Expect \"{\" before class body');\n\n    const methods: Statement.FunctionStatement[] = [];\n    while (!this.check(TokenType.RIGHT_BRACE) && !this.isAtEnd()) {\n      methods.push(this.funDecl('method'));\n    }\n\n    this.consume(TokenType.RIGHT_BRACE, 'Expect \"}\" after class body');\n\n    return new Statement.ClassStatement(name, superclass, methods);\n  }\n\n  varDecl(): Statement.VarStatement {\n    const name = this.consume(TokenType.IDENTIFIER, 'Expect variable name');\n    let initializer;\n    if (this.match([TokenType.EQUAL])) {\n      initializer = this.expression();\n    }\n\n    this.consume(TokenType.SEMICOLON, 'Expect \";\" after variable declaration');\n    return new Statement.VarStatement(name, initializer);\n  }\n\n  statement(): Statement.BaseStatement {\n    if (this.match([TokenType.IF])) {\n      return this.ifStmt();\n    }\n\n    if (this.match([TokenType.PRINT])) {\n      return this.printStmt();\n    }\n\n    if (this.match([TokenType.RETURN])) {\n      return this.returnStmt();\n    }\n\n    if (this.match([TokenType.WHILE])) {\n      return this.whileStmt();\n    }\n\n    if (this.match([TokenType.FOR])) {\n      return this.forStmt();\n    }\n\n    if (this.match([TokenType.LEFT_BRACE])) {\n      return new Statement.BlockStatement(this.block());\n    }\n\n    return this.exprStmt();\n  }\n\n  ifStmt(): Statement.IfStatement {\n    this.consume(TokenType.LEFT_PARENTHESE, 'Expect \"(\" after \"if\"');\n\n    const condition = this.expression();\n\n    this.consume(TokenType.RIGHT_PARENTHESE, 'Expect \")\" after if condition');\n\n    const thenBranch = this.statement();\n    const elseBranch = this.match([TokenType.ELSE])\n      ? this.statement()\n      : undefined;\n\n    return new Statement.IfStatement(condition, thenBranch, elseBranch);\n  }\n\n  block(): Statement.BaseStatement[] {\n    const statements: Statement.BaseStatement[] = [];\n\n    while (!this.check(TokenType.RIGHT_BRACE) && !this.isAtEnd()) {\n      const statement = this.declaration();\n      if (statement) {\n        statements.push(statement);\n      }\n    }\n\n    this.consume(TokenType.RIGHT_BRACE, 'Expect \"}\" after block');\n    return statements;\n  }\n\n  exprStmt(): Statement.ExpressionStatement {\n    const expression = this.expression();\n    this.consume(TokenType.SEMICOLON, 'Expect \";\" after expression');\n    return new Statement.ExpressionStatement(expression);\n  }\n\n  printStmt(): Statement.PrintStatement {\n    const expression = this.expression();\n    this.consume(TokenType.SEMICOLON, 'Expect \";\" after value');\n    return new Statement.PrintStatement(expression);\n  }\n\n  returnStmt(): Statement.ReturnStatement {\n    const keyword = this.previous();\n    const value = this.check(TokenType.SEMICOLON)\n      ? new Expression.LiteralExpression(null)\n      : this.expression();\n    this.consume(TokenType.SEMICOLON, 'Expect \";\" after return value');\n    return new Statement.ReturnStatement(keyword, value);\n  }\n\n  whileStmt(): Statement.WhileStatement {\n    this.consume(TokenType.LEFT_PARENTHESE, 'Expect \"(\" after \"while\"');\n    const condition = this.expression();\n    this.consume(TokenType.RIGHT_PARENTHESE, 'Expect \")\" after condition');\n    const statement = this.statement();\n    return new Statement.WhileStatement(condition, statement);\n  }\n\n  forStmt(): Statement.ForStatement {\n    this.consume(TokenType.LEFT_PARENTHESE, 'Expect \"(\" after \"for\"');\n\n    if (this.check(TokenType.RIGHT_PARENTHESE)) {\n      this.errors.push({\n        line: this.peek().line,\n        column: this.peek().column,\n        message: 'There is nothing exist in the parenthese of \"for\"',\n      });\n      throw new Error();\n    }\n\n    let initializer;\n    let condition;\n    let updator;\n\n    if (!this.check(TokenType.SEMICOLON)) {\n      initializer = this.declaration();\n    } else {\n      this.advance();\n    }\n\n    if (!this.match([TokenType.SEMICOLON])) {\n      condition = this.expression();\n      this.consume(\n        TokenType.SEMICOLON,\n        'Expect \";\" after the condition of \"for\"',\n      );\n    }\n\n    if (!this.match([TokenType.RIGHT_PARENTHESE])) {\n      updator = this.expression();\n      this.consume(\n        TokenType.RIGHT_PARENTHESE,\n        'Expect \")\" after the parenthese of \"for\"',\n      );\n    }\n\n    const body = this.statement();\n\n    return new Statement.ForStatement({\n      initializer,\n      condition,\n      updator,\n      body,\n    });\n  }\n\n  expression(): Expression.BaseExpression {\n    return this.assignment();\n  }\n\n  assignment(): Expression.BaseExpression {\n    let expression = this.logicOr();\n\n    if (this.match([TokenType.EQUAL])) {\n      const equals = this.previous();\n      const value = this.assignment();\n\n      if (expression instanceof Expression.VariableExpression) {\n        const name = expression.name;\n        return new Expression.AssignmentExpression(name, value);\n      } else if (expression instanceof Expression.GetExpression) {\n        return new Expression.SetExpression(\n          expression.object,\n          expression.name,\n          value,\n        );\n      }\n\n      this.errors.push({\n        line: equals.line,\n        column: equals.column,\n        message: 'Invalid assignment target',\n      });\n      throw new Error();\n    }\n\n    return expression;\n  }\n\n  logicOr(): Expression.BaseExpression {\n    let expression = this.logicAnd();\n\n    while (this.match([TokenType.OR])) {\n      const operator = this.previous();\n      const right = this.logicAnd();\n      expression = new Expression.LogicalExpression(\n        expression,\n        operator,\n        right,\n      );\n    }\n\n    return expression;\n  }\n\n  logicAnd(): Expression.BaseExpression {\n    let expression = this.equality();\n\n    while (this.match([TokenType.AND])) {\n      const operator = this.previous();\n      const right = this.equality();\n      expression = new Expression.LogicalExpression(\n        expression,\n        operator,\n        right,\n      );\n    }\n\n    return expression;\n  }\n\n  equality(): Expression.BaseExpression {\n    let expression = this.comparison();\n\n    while (this.match([TokenType.BANG_EQUAL, TokenType.EQUAL_EQUAL])) {\n      const operator = this.previous();\n      const right = this.comparison();\n      expression = new Expression.BinaryExpression(expression, operator, right);\n    }\n\n    return expression;\n  }\n\n  comparison(): Expression.BaseExpression {\n    let expression = this.term();\n\n    while (\n      this.match([\n        TokenType.GREATER,\n        TokenType.GREATER_EQUAL,\n        TokenType.LESS,\n        TokenType.LESS_EQUAL,\n      ])\n    ) {\n      const operator = this.previous();\n      const right = this.term();\n      expression = new Expression.BinaryExpression(expression, operator, right);\n    }\n\n    return expression;\n  }\n\n  term(): Expression.BaseExpression {\n    let expression = this.factor();\n\n    while (this.match([TokenType.MINUS, TokenType.PLUS])) {\n      const operator = this.previous();\n      const right = this.factor();\n      expression = new Expression.BinaryExpression(expression, operator, right);\n    }\n\n    return expression;\n  }\n\n  factor(): Expression.BaseExpression {\n    let expression = this.unary();\n\n    while (this.match([TokenType.SLASH, TokenType.STAR])) {\n      const operator = this.previous();\n      const right = this.unary();\n      expression = new Expression.BinaryExpression(expression, operator, right);\n    }\n\n    return expression;\n  }\n\n  unary(): Expression.BaseExpression {\n    if (this.match([TokenType.BANG, TokenType.MINUS])) {\n      const operator = this.previous();\n      const right = this.unary();\n      return new Expression.UnaryExpression(operator, right);\n    }\n\n    return this.call();\n  }\n\n  call(): Expression.BaseExpression {\n    let expression = this.primary();\n\n    while (this.match([TokenType.LEFT_PARENTHESE, TokenType.DOT])) {\n      const previousType = this.previous().type;\n      if (previousType === TokenType.LEFT_PARENTHESE) {\n        expression = this.finishCall(expression);\n      } else if (previousType === TokenType.DOT) {\n        const name = this.consume(\n          TokenType.IDENTIFIER,\n          'Expect property name after \".\"',\n        );\n        expression = new Expression.GetExpression(expression, name);\n      }\n    }\n\n    return expression;\n  }\n\n  finishCall(callee: Expression.BaseExpression): Expression.BaseExpression {\n    const args: Expression.BaseExpression[] = [];\n\n    if (!this.check(TokenType.RIGHT_PARENTHESE)) {\n      do {\n        args.push(this.expression());\n      } while (this.match([TokenType.COMMA]));\n    }\n\n    const endParenthese = this.consume(\n      TokenType.RIGHT_PARENTHESE,\n      'Expect \")\" after arguments',\n    );\n\n    return new Expression.CallExpression(callee, args, endParenthese);\n  }\n\n  primary(): Expression.BaseExpression {\n    if (this.match([TokenType.NUMBER, TokenType.STRING])) {\n      return new Expression.LiteralExpression(\n        this.previous().literal as LiteralValue,\n      );\n    }\n\n    if (this.match([TokenType.TRUE])) {\n      return new Expression.LiteralExpression(true);\n    }\n\n    if (this.match([TokenType.FALSE])) {\n      return new Expression.LiteralExpression(false);\n    }\n\n    if (this.match([TokenType.NIL])) {\n      return new Expression.LiteralExpression(null);\n    }\n\n    if (this.match([TokenType.THIS])) {\n      return new Expression.ThisExpression(this.previous());\n    }\n\n    if (this.match([TokenType.SUPER])) {\n      const keyword = this.previous();\n      this.consume(TokenType.DOT, 'Expect \".\" after \"super\"');\n      this.consume(TokenType.IDENTIFIER, 'Expect superclass method name');\n      return new Expression.SuperExpression(keyword, this.previous());\n    }\n\n    if (this.match([TokenType.IDENTIFIER])) {\n      return new Expression.VariableExpression(this.previous());\n    }\n\n    if (this.match([TokenType.LEFT_PARENTHESE])) {\n      const expression = new Expression.GroupingExpression(this.expression());\n      this.consume(TokenType.RIGHT_PARENTHESE, 'Expect \")\" after expression');\n      return expression;\n    }\n\n    this.errors.push({\n      line: this.peek().line,\n      column: this.peek().column,\n      message: `Unexpected token \"${this.peek().lexeme}\"`,\n    });\n    throw new Error();\n  }\n\n  match(tokenTypes: TokenType[]): boolean {\n    for (let i = 0; i < tokenTypes.length; i++) {\n      if (this.check(tokenTypes[i])) {\n        this.advance();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  consume(tokenType: TokenType, message: string): Token {\n    if (this.check(tokenType)) {\n      return this.advance();\n    }\n\n    this.errors.push({\n      line: this.previous().line,\n      column: this.previous().column,\n      message,\n    });\n    throw new Error();\n  }\n\n  check(tokenType: TokenType): boolean {\n    if (this.isAtEnd()) {\n      return false;\n    }\n\n    return tokenType === this.peek().type;\n  }\n\n  advance(): Token {\n    if (!this.isAtEnd()) {\n      this.current++;\n    }\n    return this.previous();\n  }\n\n  peek(): Token {\n    return this.tokens[this.current];\n  }\n\n  previous(): Token {\n    return this.tokens[this.current - 1];\n  }\n\n  isAtEnd(): boolean {\n    return this.peek().type === TokenType.EOF;\n  }\n\n  synchronize() {\n    // avoid endless loop\n    this.advance();\n\n    while (!this.isAtEnd()) {\n      if (this.previous().type === TokenType.SEMICOLON) return;\n\n      switch (this.peek().type) {\n        case TokenType.CLASS:\n        case TokenType.FUN:\n        case TokenType.VAR:\n        case TokenType.FOR:\n        case TokenType.IF:\n        case TokenType.WHILE:\n        case TokenType.PRINT:\n        case TokenType.RETURN:\n          return;\n      }\n\n      this.advance();\n    }\n  }\n}\n\nexport { Parser as default, Expression, Statement };\n","function produceError(line: number, column: number, message: string): Error {\n  return new Error(`${message} in line ${line} column ${column}.`);\n}\n\nexport default produceError;\n","import { Token, LiteralValue } from '../scanner';\nimport { produceError } from '../util';\nimport { LoxClass, LoxFunction, LoxInstance } from '../interpreter';\n\nexport type EnvironmentValue =\n  | LoxClass\n  | LoxFunction\n  | LoxInstance\n  | LiteralValue;\nclass Environment {\n  values: Record<string, EnvironmentValue>;\n  enclosing?: Environment;\n\n  constructor(enclosing?: Environment) {\n    this.values = {};\n    this.enclosing = enclosing;\n  }\n\n  define(name: string, value: EnvironmentValue): void {\n    this.values[name] = value;\n  }\n\n  get(name: Token): EnvironmentValue {\n    if (name.lexeme in this.values) {\n      return this.values[name.lexeme];\n    }\n\n    if (this.enclosing) {\n      return this.enclosing.get(name);\n    }\n\n    throw produceError(\n      name.line,\n      name.column,\n      `Undefined variable at \"${name.lexeme}\"`,\n    );\n  }\n\n  getEnvironmentByDistance(distance: number): Environment {\n    let environment: Environment = this;\n\n    while (distance > 0 && environment.enclosing) {\n      environment = environment.enclosing;\n      distance = distance - 1;\n    }\n\n    return environment;\n  }\n\n  assign(name: Token, value: EnvironmentValue): void {\n    if (name.lexeme in this.values) {\n      this.values[name.lexeme] = value;\n      return;\n    }\n\n    if (this.enclosing) {\n      this.enclosing.assign(name, value);\n      return;\n    }\n\n    throw produceError(\n      name.line,\n      name.column,\n      `Undefined variable at \"${name.lexeme}\"`,\n    );\n  }\n}\n\nexport default Environment;\n","import { Token } from '../scanner';\nimport { produceError } from '../util';\nimport { EnvironmentValue } from '../environment';\nimport LoxClass from './LoxClass';\n\nclass LoxInstance {\n  belongClass: LoxClass;\n  fields: Record<string, EnvironmentValue>;\n\n  constructor(belongClass: LoxClass) {\n    this.belongClass = belongClass;\n    this.fields = {};\n  }\n\n  get(name: Token): EnvironmentValue {\n    if (name.lexeme in this.fields) {\n      return this.fields[name.lexeme];\n    }\n\n    const method = this.belongClass.findMethod(name.lexeme);\n    if (method) {\n      return method.bind(this);\n    }\n\n    throw produceError(\n      name.line,\n      name.column,\n      `Undefined property \"${name.lexeme}\"`,\n    );\n  }\n\n  set(name: Token, value: EnvironmentValue): void {\n    this.fields[name.lexeme] = value;\n  }\n}\n\nexport default LoxInstance;\n","import { EnvironmentValue } from '../environment';\nimport Interpreter from '.';\nimport LoxFunction from './LoxFunction';\nimport LoxInstance from './LoxInstance';\n\nclass LoxClass {\n  name: string;\n  superclass: LoxClass | null;\n  methods: Record<string, LoxFunction>;\n\n  constructor(\n    name: string,\n    superclass: LoxClass | null,\n    methods: Record<string, LoxFunction>,\n  ) {\n    this.name = name;\n    this.superclass = superclass;\n    this.methods = methods;\n  }\n\n  arity(): number {\n    let initializer = this.methods.init;\n    if (initializer) {\n      return initializer.arity();\n    }\n    return 0;\n  }\n\n  findMethod(name: string): LoxFunction | null {\n    if (name in this.methods) {\n      return this.methods[name];\n    }\n\n    if (this.superclass) {\n      return this.superclass.findMethod(name);\n    }\n\n    return null;\n  }\n\n  call(interpreter: Interpreter, args: EnvironmentValue[]): LoxInstance {\n    const instance = new LoxInstance(this);\n    const initializer = this.methods.init;\n    if (initializer) {\n      initializer.bind(instance).call(interpreter, args);\n    }\n    return instance;\n  }\n}\n\nexport default LoxClass;\n","import { EnvironmentValue } from '../environment';\n\nclass LoxReturn {\n  value: EnvironmentValue;\n\n  constructor(value: EnvironmentValue) {\n    this.value = value;\n  }\n}\n\nexport default LoxReturn;\n","import { Statement } from '../parser';\nimport Environment, { EnvironmentValue } from '../environment';\nimport Interpreter from '.';\nimport LoxReturn from './LoxReturn';\nimport LoxInstance from './LoxInstance';\n\nclass LoxFunction {\n  declaration: Statement.FunctionStatement;\n  closure: Environment;\n  isInitializer: boolean;\n\n  constructor(\n    declaration: Statement.FunctionStatement,\n    closure: Environment,\n    isInitializer?: boolean,\n  ) {\n    this.declaration = declaration;\n    this.closure = closure;\n    this.isInitializer = !!isInitializer;\n  }\n\n  arity(): number {\n    return this.declaration.params.length;\n  }\n\n  call(interpreter: Interpreter, args: EnvironmentValue[]): EnvironmentValue {\n    const environment = new Environment(this.closure);\n\n    for (let i = 0; i < this.declaration.params.length; i++) {\n      environment.define(this.declaration.params[i].lexeme, args[i]);\n    }\n\n    let returnVal = null;\n    try {\n      interpreter.visitBlockStatement(this.declaration.body, environment);\n    } catch (error) {\n      if (error instanceof LoxReturn) {\n        returnVal = error.value;\n      } else {\n        throw error;\n      }\n    }\n\n    if (this.isInitializer) {\n      return this.closure.values.this;\n    }\n\n    return returnVal;\n  }\n\n  bind(instance: LoxInstance): LoxFunction {\n    const environment = new Environment(this.closure);\n    environment.define('this', instance);\n    return new LoxFunction(this.declaration, environment, this.isInitializer);\n  }\n}\n\nexport default LoxFunction;\n","import { Token, TokenType, LiteralValue } from '../scanner';\nimport { Expression, Statement } from '../parser';\nimport Environment, { EnvironmentValue } from '../environment';\nimport { produceError } from '../util';\nimport LoxClass from './LoxClass';\nimport LoxFunction from './LoxFunction';\nimport LoxInstance from './LoxInstance';\nimport LoxReturn from './LoxReturn';\n\nclass Interpreter {\n  global: Environment;\n  environment: Environment;\n  statements: Statement.BaseStatement[];\n  scopeRecord: Map<Expression.BaseExpression, number>;\n\n  constructor(\n    statements: Statement.BaseStatement[],\n    scopeRecord?: Map<Expression.BaseExpression, number>,\n  ) {\n    this.global = new Environment();\n    this.environment = this.global;\n    this.statements = statements;\n    this.scopeRecord = scopeRecord || new Map();\n  }\n\n  interpret(): void {\n    for (let i = 0; i < this.statements.length; i++) {\n      this.execute(this.statements[i]);\n    }\n  }\n\n  evaluate(node: Expression.BaseExpression): EnvironmentValue {\n    return node.accept(this);\n  }\n\n  execute(node: Statement.BaseStatement): void {\n    node.accept(this);\n  }\n\n  visitFunctionStatement(node: Statement.FunctionStatement): void {\n    const loxFunction = new LoxFunction(node, this.environment);\n    this.environment.define(node.name.lexeme, loxFunction);\n  }\n\n  visitClassStatement(node: Statement.ClassStatement): void {\n    this.environment.define(node.name.lexeme, null);\n\n    let superclass = null;\n    let previous = null;\n    if (node.superclass) {\n      superclass = this.evaluate(node.superclass);\n\n      if (!(superclass instanceof LoxClass)) {\n        throw produceError(\n          node.superclass.name.line,\n          node.superclass.name.column,\n          `Superclass must be a class at \"${node.superclass.name.lexeme}\"`,\n        );\n      }\n\n      previous = this.environment;\n      this.environment = new Environment(previous);\n      this.environment.define('super', superclass);\n    }\n\n    const methods = node.methods.reduce((pre, cur) => {\n      const method = new LoxFunction(\n        cur,\n        this.environment,\n        cur.name.lexeme === 'init',\n      );\n      return {\n        ...pre,\n        [cur.name.lexeme]: method,\n      };\n    }, {});\n\n    const loxClass = new LoxClass(node.name.lexeme, superclass, methods);\n\n    if (previous) {\n      this.environment = previous;\n    }\n\n    this.environment.assign(node.name, loxClass);\n  }\n\n  visitReturnStatement(node: Statement.ReturnStatement): void {\n    throw new LoxReturn(this.evaluate(node.value));\n  }\n\n  visitExpressionStatement(node: Statement.ExpressionStatement): void {\n    this.evaluate(node.expression);\n  }\n\n  visitIfStatement(node: Statement.IfStatement): void {\n    if (this.evaluate(node.condition)) {\n      this.execute(node.thenBranch);\n    } else if (node.elseBranch) {\n      this.execute(node.elseBranch);\n    }\n  }\n\n  visitWhileStatement(node: Statement.WhileStatement): void {\n    while (this.evaluate(node.condition)) {\n      this.execute(node.body);\n    }\n  }\n\n  visitForStatement(node: Statement.ForStatement): void {\n    const previous = this.environment;\n    this.environment = new Environment(previous);\n\n    node.initializer && this.evaluate(node.initializer);\n    while (node.condition && this.evaluate(node.condition)) {\n      this.execute(node.body);\n      node.updator && this.evaluate(node.updator);\n    }\n\n    this.environment = previous;\n  }\n\n  visitPrintStatement(node: Statement.PrintStatement): void {\n    const val = this.evaluate(node.expression);\n    console.log(val);\n  }\n\n  visitVarStatement(node: Statement.VarStatement): void {\n    const value = node.initializer ? this.evaluate(node.initializer) : null;\n\n    this.environment.define(node.name.lexeme, value);\n  }\n\n  visitBlockStatement(\n    node: Statement.BlockStatement,\n    newEnvironment?: Environment,\n  ): void {\n    const previous = this.environment;\n    this.environment = newEnvironment || new Environment(this.environment);\n\n    try {\n      for (let i = 0; i < node.statements.length; i++) {\n        this.execute(node.statements[i]);\n      }\n    } catch (error) {\n      this.environment = previous;\n      throw error;\n    }\n\n    this.environment = previous;\n  }\n\n  visitLiteralExpression(node: Expression.LiteralExpression): LiteralValue {\n    return node.value;\n  }\n\n  visitGroupingExpression(\n    node: Expression.GroupingExpression,\n  ): EnvironmentValue {\n    return this.evaluate(node.expression);\n  }\n\n  visitUnaryExpression(node: Expression.UnaryExpression): EnvironmentValue {\n    const right = this.evaluate(node.expression);\n\n    if (node.operator.type === TokenType.MINUS) {\n      if (typeof right !== 'number') {\n        throw produceError(\n          node.operator.line,\n          node.operator.column,\n          `Operand must be a number at \"${node.operator.lexeme}\"`,\n        );\n      }\n      return -right;\n    }\n\n    if (node.operator.type === TokenType.BANG) {\n      return !right;\n    }\n\n    throw produceError(\n      node.operator.line,\n      node.operator.column,\n      'Should not happen',\n    );\n  }\n\n  visitBinaryExpression(\n    node: Expression.BinaryExpression,\n  ): number | string | boolean {\n    const left = this.evaluate(node.left);\n    const right = this.evaluate(node.right);\n\n    switch (node.operator.type) {\n      case TokenType.PLUS:\n        if (typeof left === 'number' && typeof right === 'number') {\n          return left + right;\n        }\n\n        if (typeof left === 'string' && typeof right === 'string') {\n          return left + right;\n        }\n\n        throw produceError(\n          node.operator.line,\n          node.operator.column,\n          `Operands must be two numbers or two strings \"${node.operator.lexeme}\"`,\n        );\n      case TokenType.MINUS:\n      case TokenType.SLASH:\n      case TokenType.STAR:\n      case TokenType.GREATER:\n      case TokenType.GREATER_EQUAL:\n      case TokenType.LESS:\n      case TokenType.LESS_EQUAL:\n        return this.numberBinaryCalculate(node.operator, left, right);\n      case TokenType.BANG_EQUAL:\n        return left !== right;\n      case TokenType.EQUAL_EQUAL:\n        return left === right;\n      default:\n        throw produceError(\n          node.operator.line,\n          node.operator.column,\n          'Should not happen',\n        );\n    }\n  }\n\n  numberBinaryCalculate(\n    token: Token,\n    left: EnvironmentValue,\n    right: EnvironmentValue,\n  ): number | boolean {\n    if (typeof left !== 'number' || typeof right !== 'number') {\n      throw produceError(\n        token.line,\n        token.column,\n        `Operands must be numbers at \"${token.lexeme}\"`,\n      );\n    }\n    switch (token.type) {\n      case TokenType.MINUS:\n        return left - right;\n      case TokenType.SLASH:\n        return left / right;\n      case TokenType.STAR:\n        return left * right;\n      case TokenType.GREATER:\n        return left > right;\n      case TokenType.GREATER_EQUAL:\n        return left >= right;\n      case TokenType.LESS:\n        return left < right;\n      case TokenType.LESS_EQUAL:\n        return left <= right;\n      default:\n        throw produceError(token.line, token.column, 'Should not happen');\n    }\n  }\n\n  visitLogicalExpression(node: Expression.LogicalExpression): EnvironmentValue {\n    const left = this.evaluate(node.left);\n\n    if (node.operator.type === TokenType.OR) {\n      if (left) {\n        return left;\n      }\n      return this.evaluate(node.right);\n    }\n\n    if (node.operator.type === TokenType.AND) {\n      if (left) {\n        return this.evaluate(node.right);\n      }\n      return left;\n    }\n\n    throw produceError(\n      node.operator.line,\n      node.operator.column,\n      'Should not happen',\n    );\n  }\n\n  visitAssignmentExpression(\n    node: Expression.AssignmentExpression,\n  ): EnvironmentValue {\n    const value = this.evaluate(node.value);\n\n    if (!this.scopeRecord.has(node)) {\n      this.global.assign(node.name, value);\n      return value;\n    }\n\n    const distance = this.scopeRecord.get(node)!;\n    const environment = this.environment.getEnvironmentByDistance(distance);\n\n    environment.assign(node.name, value);\n\n    return value;\n  }\n\n  visitVariableExpression(\n    node: Expression.VariableExpression,\n  ): EnvironmentValue {\n    if (!this.scopeRecord.has(node)) {\n      return this.global.get(node.name);\n    }\n\n    const distance = this.scopeRecord.get(node)!;\n    const environment = this.environment.getEnvironmentByDistance(distance);\n\n    return environment.get(node.name);\n  }\n\n  visitCallExpression(node: Expression.CallExpression): EnvironmentValue {\n    const callee = this.evaluate(node.callee);\n    const args = node.args.map((item) => this.evaluate(item));\n\n    if (!(callee instanceof LoxFunction || callee instanceof LoxClass)) {\n      throw produceError(\n        node.endParenthese.line,\n        node.endParenthese.column,\n        `Can only call functions and classes at \"${node.endParenthese.lexeme}\"`,\n      );\n    }\n\n    if (args.length !== callee.arity()) {\n      throw produceError(\n        node.endParenthese.line,\n        node.endParenthese.column,\n        `Expect ${callee.arity()} arguments but got ${args.length} at \")\"`,\n      );\n    }\n\n    return callee.call(this, args);\n  }\n\n  visitGetExpression(node: Expression.GetExpression): EnvironmentValue {\n    const obj = this.evaluate(node.object);\n    if (obj instanceof LoxInstance) {\n      return obj.get(node.name);\n    }\n\n    throw produceError(\n      node.name.line,\n      node.name.column,\n      `Only instances have properties at \"${node.name.lexeme}\"`,\n    );\n  }\n\n  visitSetExpression(node: Expression.SetExpression): EnvironmentValue {\n    const obj = this.evaluate(node.object);\n\n    if (obj instanceof LoxInstance) {\n      const value = this.evaluate(node.value);\n\n      obj.set(node.name, value);\n\n      return value;\n    }\n\n    throw produceError(\n      node.name.line,\n      node.name.column,\n      `Only instances have properties at \"${node.name.lexeme}\"`,\n    );\n  }\n\n  visitThisExpression(node: Expression.ThisExpression): LoxInstance {\n    const distance = this.scopeRecord.get(node)!;\n    const environment = this.environment.getEnvironmentByDistance(distance);\n\n    return environment.get(node.keyword) as LoxInstance;\n  }\n\n  visitSuperExpression(node: Expression.SuperExpression): LoxFunction {\n    const distance = this.scopeRecord.get(node)!;\n    const environment = this.environment.getEnvironmentByDistance(distance);\n\n    const superclass = environment.get(node.keyword) as LoxClass;\n    const obj = this.environment.getEnvironmentByDistance(distance - 1).values\n      .this as LoxInstance;\n\n    const method = superclass.findMethod(node.method.lexeme);\n\n    if (method) {\n      return method.bind(obj);\n    }\n\n    throw produceError(\n      node.keyword.line,\n      node.keyword.column,\n      `Undefined property ${node.method.lexeme}`,\n    );\n  }\n}\n\nexport { Interpreter as default, LoxClass, LoxFunction, LoxInstance };\n","import Scanner from './scanner';\nimport Parser from './parser';\nimport { ScopeAnalyst } from './semantic';\nimport Interpreter from './interpreter';\n\nclass Compiler {\n  source: string;\n  scanner!: Scanner;\n  parser!: Parser;\n  scopeAnalyst!: ScopeAnalyst;\n  interpreter!: Interpreter;\n\n  constructor(source: string) {\n    this.source = source;\n  }\n\n  analysis() {\n    this.scanner = new Scanner(this.source);\n    this.scanner.scan();\n    this.parser = new Parser(this.scanner.tokens);\n    this.parser.parse();\n    this.scopeAnalyst = new ScopeAnalyst(this.parser.statements);\n    this.scopeAnalyst.analysis();\n    this.interpreter = new Interpreter(\n      this.parser.statements,\n      this.scopeAnalyst.scopeRecord,\n    );\n  }\n\n  run() {\n    this.interpreter.interpret();\n  }\n}\n\nexport default Compiler;\n","/* eslint-disable react-hooks/exhaustive-deps */\nimport React, { useState, useRef, useCallback, useEffect } from 'react';\nimport Editor from '@monaco-editor/react';\nimport { Tabs, List, Button } from 'antd';\nimport { CloseCircleOutlined, CaretRightOutlined } from '@ant-design/icons';\nimport { debounce } from 'lodash';\n\nimport Compiler from '../../compiler';\nimport './style.css';\n\nconst PROBLEMS = 'Problems';\nconst CONSOLE = 'Console';\nconst TAB_CONFIGS = [\n  {\n    key: PROBLEMS,\n    label: PROBLEMS,\n  },\n  {\n    key: CONSOLE,\n    label: CONSOLE,\n  },\n];\n\nfunction Playground({ show }: { show: boolean }) {\n  const [activeKey, setActiveKey] = useState<string>(TAB_CONFIGS[0].key);\n  const [errors, setErrors] = useState<string[]>([]);\n  const [output, setOutput] = useState<any[]>([]);\n\n  const compilerRef = useRef<Compiler>();\n\n  const handleCodeChange = useCallback(\n    debounce((code: string) => {\n      const compiler = new Compiler(code);\n      compilerRef.current = compiler;\n      compiler.analysis();\n      // @ts-ignore\n      window.zzz = compiler;\n      const newErrors = compiler.scanner.errors\n        .concat(compiler.parser.errors, compiler.scopeAnalyst.errors)\n        .map((item) => {\n          return `${item.message} in line ${item.line} column ${item.column}.`;\n        });\n      setErrors(newErrors);\n    }, 500),\n    [],\n  );\n\n  const handleRun = () => {\n    if (compilerRef.current) {\n      try {\n        compilerRef.current.run();\n      } catch (err) {\n        setOutput((pre) => [...pre, (err as Error).message]);\n      }\n    }\n  };\n\n  useEffect(() => {\n    const originalLog = console.log;\n    console.log = (...data: any[]) => {\n      setOutput((pre) => [\n        ...pre,\n        ...data.map((item) => {\n          if (item === null) {\n            return 'null';\n          }\n\n          if (!(item instanceof Object)) {\n            return item;\n          }\n\n          try {\n            return JSON.stringify(item);\n          } catch (err) {\n            return Object.prototype.toString.apply(item);\n          }\n        }),\n      ]);\n      originalLog(...data);\n    };\n  }, []);\n\n  return (\n    <div className=\"playground\" style={{ display: show ? '' : 'none' }}>\n      <Editor\n        height=\"65%\"\n        defaultLanguage=\"plaintext\"\n        onChange={(value) => {\n          handleCodeChange(value || '');\n        }}\n      />\n      <div className=\"terminal\">\n        <Tabs\n          activeKey={activeKey}\n          onChange={setActiveKey}\n          tabBarExtraContent={\n            <>\n              <Button\n                danger\n                icon={<CloseCircleOutlined />}\n                style={{ marginRight: 16 }}\n                onClick={() => setOutput([])}\n              >\n                <span style={{ transform: 'translateY(-1px)' }}>Clear</span>\n              </Button>\n              <Button\n                style={{ background: '#52c41a' }}\n                icon={<CaretRightOutlined />}\n                disabled={!compilerRef.current || errors.length > 0}\n                onClick={handleRun}\n              >\n                <span style={{ transform: 'translateY(-1px)' }}>Run</span>\n              </Button>\n            </>\n          }\n        >\n          {TAB_CONFIGS.map((item) => {\n            let Content: React.ReactNode = null;\n            if (item.key === PROBLEMS) {\n              Content = (\n                <List\n                  header={null}\n                  footer={null}\n                  bordered\n                  dataSource={errors}\n                  renderItem={(item) => <List.Item>{item}</List.Item>}\n                />\n              );\n            } else if (item.key === CONSOLE) {\n              Content = (\n                <List\n                  header={null}\n                  footer={null}\n                  bordered\n                  dataSource={output}\n                  renderItem={(item) => <List.Item>{item}</List.Item>}\n                />\n              );\n            }\n\n            let tabName = item.key;\n            if (item.key === PROBLEMS && errors.length > 0) {\n              tabName += `(${errors.length})`;\n            }\n\n            return (\n              <Tabs.TabPane tab={tabName} key={item.key}>\n                {Content}\n              </Tabs.TabPane>\n            );\n          })}\n        </Tabs>\n      </div>\n    </div>\n  );\n}\n\nexport default Playground;\n","import React, { useState } from 'react';\nimport { Menu } from 'antd';\n\nimport Playground from './page/Playground';\nimport './App.css';\n\nconst PLAYGROUND = 'Playground';\nconst GRAMMER = 'Grammer';\n\nfunction App() {\n  const [active, setActive] = useState<string>(PLAYGROUND);\n\n  return (\n    <div className=\"App\">\n      <Menu\n        mode=\"inline\"\n        theme=\"dark\"\n        selectedKeys={[active]}\n        onClick={(item) => setActive(item.key)}\n      >\n        <Menu.Item key={PLAYGROUND}>{PLAYGROUND}</Menu.Item>\n        <Menu.Item key={GRAMMER}>{GRAMMER}</Menu.Item>\n      </Menu>\n      <Playground show={active === PLAYGROUND} />\n      <iframe\n        style={{\n          display: active === GRAMMER ? '' : 'none',\n          flex: 'auto',\n          height: '100%',\n          border: 'none',\n        }}\n        title=\"grammer\"\n        src=\"https://craftinginterpreters.com/the-lox-language.html\"\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}